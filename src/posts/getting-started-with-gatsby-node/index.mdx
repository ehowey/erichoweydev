---
title: Getting started with gatsby-node
author: Eric Howey
authorLink: https://twitter.com/erchwy
categories: [Gatsby]
date: 2022-06-20
featuredImage: ./featured.jpg
featuredImageCaption: Photo by Pietro Jeng on Unsplash
socialImage: ./social.jpg
published: false
---

Gatsby does a lot of things well but its superpower (in my opinion) is the [GraphQL data layer](https://www.gatsbyjs.com/docs/reference/graphql-data-layer/). What Gatsby has coined the "content mesh". Plugins allow you to customize and add to this data layer but _eventually_ you will probably find yourself needing to do something more.

Maybe you need to grab some geolocation data at build time, add a custom excerpt field, or transform some dates.

Enter `gatsby-node.js`.

This is where the magic of creating the content mesh happens and Gatsby provides [a ton of APIs](https://www.gatsbyjs.com/docs/reference/config-files/gatsby-node/) to hook into the node creation process at different points in the build process.

Gatsby has great docs on [cuztomizing the GraphQL schema](https://www.gatsbyjs.com/docs/reference/graphql-data-layer/schema-customization/) but I still have found `gatsby-node` intimidating and tricky to work with at times. Testing changes means restarting the development server, so the feedback loop is slower; and then there is also [GraphQL schema definitions](https://graphql.org/learn/schema/) to understand as well. It can feel like a lot.

Hopefully this article helps you to get the most out of `gatsby-node` and also makes some of the core APIs easier to work with.

Let's go!

## What is a node?

If you have been anywhere near web development in the last ten years chances are you have heard of NodeJS. These are a different kind of node.

In this article, and in Gatsby, nodes are discrete reference points to individual data within the larger GraphQL schema. My mental model for understanding this is a tree with branches and leaves. Each branch is a "schema" and each leaf on the branch is a "node". For example imagine a schema for a blog article (our proverbial branch), this schema would include nodes for things like the title, author, image, date, etc (our leaves). These schemas are then all linked together to form the tree, our entire GraphQL schema.

So in this article when you hear me talking about nodes we are talking about points of data connected within the larger "content mesh". Hundreds or thousands of leaves on a tree.

## Gatsby's data pipeline

Let's take a step back and do a brief review of what is happening in Gatsby's data pipeline as a site is built. Sticking with our tree metaphor we _very quickly_ grow a tree and then chop it down to build a home. Data in, web pages out.

1. Schema definition (createSchemaCustomization)
1. Source data from external APIs and internal files (sourceNodes)
1. Automatic schema inference from these data sources (sourceNodes)
1. Extend or customize the now existing GraphQl nodes (createResolvers)
1. Finally use the data layer to compose pages (createPages)

The four most important APIs to understand are `createSchemaCustomization`, `sourceNodes`, `createResolvers` and `createPages`. If you understand these 4 you unlock Gatsby superpowers!

## An imaginary store

Throughout this article we will reference an imaginary store with thousands of products. All with some slightly different product metadata. This is a good example of where customizing the schema is beneficial and allows for two key improvements; faster node creation and more accurate node creation. Gatsby generally does a great job of inferring nodes with consistent data, e.g. blog posts, but with complex schemas like for store products it can run into problems properly inferring all of the node types.

Here is the general product schema we will be referencing throughout, note that we have a boolean, array, integer, strings.

```json
{
  "title": "Sneakers",
  "price": 1000,
  "color": "red",
  "sizes": ["sm", "md", "lg"],
  "largeItem": false
}
```

Here is an example of where Gatsby might run into trouble and why we need to define the schema. Sneakers will have sizes and colors. But what about a large outdoor swing set that is on sale; there are no variations on this product but it is a large item and on sale. So its data structure might look something like:

```json
{
  "title": "Swing set",
  "price": 133000,
  "largeItem": true,
  "onSale": true
  "noShipping": true,
}
```

## createSchemaCustomization

[Official Gatsby Docs](https://www.gatsbyjs.com/docs/reference/graphql-data-layer/schema-customization/)

This is the first part of the node creation process that allows you to define the shape or form of your data for Gatsby which speeds up the build process and allows yout to set you up custom data structures.

Let's setup a structure for our store products

```js
exports.createSchemaCustomization = ({ actions }) => {
  const { createTypes } = actions
  const productTypes = `
    type Product implements Node @dontInfer {
      title: String!
      price: Int!
      color: String
      sizes: [String]
      largeItem: Boolean
      onSale: Boolean
      noShipping: Boolean
    }
  `
  createTypes(productTypes)
}
```
