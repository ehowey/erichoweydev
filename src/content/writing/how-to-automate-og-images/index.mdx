---
title: How to automate OG Images with Netlify Edge Functions
author: Eric Howey
authorLink: https://twitter.com/erchwy
categories: [Astro, Netlify]
date: 2023-10-12
published: true
description: Lorem ipsum
excerpt: Lorem ipsum
demo: https://twitter.com/erchwy
repo: https://twitter.com/erchwy
---

import BlogQuoteInfo from '~/components/BlogQuoteInfo.astro'

Automating the creation of custom [open graph (OG) images](https://ogp.me/) opens up interesting business use cases from personalized conference tickets to shareable user profiles and more. Fundamentally automated OG images unlock personalized information sharing at scale. You can manually create 10 images, maybe a couple hundred images, but if you have thousands or millions of images all needing dynamic content then this is the way to go.

Probably one of the most well known examples of this is the generated OG images for GitHub repositories. GitHub generates a social image with some basic information about the repository; stars, contributors, etc. The information is useful and it helps users make a decision about whether they want to click that link in their social media stream or not.

![Demonstration of GitHub OG Image using the repository for this website](/images/github-twitter-og.png)

<BlogQuoteInfo>
  In this blog post I am going to show how to do this using Netlify Edge
  Functions but Vercel also has a [great solution for generated OG images
  too](https://vercel.com/docs/concepts/functions/edge-functions/og-image-generation).
</BlogQuoteInfo>

## Getting setup

1. Use an existing project or initialize a fresh repository of whatever frontend framework you prefer (this demo uses Astro but it will work with NextJS, Remix, SvelteKit and others).
2. Make sure you have a current version of the [Netlify CLI](https://docs.netlify.com/cli/get-started/) by running `npm install netlify-cli -g`.
3. Create a blank edge function at `/netlify/edge-functions/og-image.ts` file. This will be where all of the magic happens!
4. Create a `netlify.toml` file in the root of your project with the following code:

```toml title="netlify.toml"
[[edge_functions]]
function = "og-image"
path = "/api/og-image"
```

5. Run `netlify dev` to start up your project using the Netlify development server which will let us test and preview the edge function. The first time you do this you should some prompts about configuring your code editor for Edge Functions.

## Making a basic image

Open up your `og-image.ts` edge function and paste in the following code:

```tsx title="og-image.ts"
/** @jsxImportSource https://esm.sh/react */
import React from 'https://esm.sh/react@18.2.0'
import { ImageResponse } from 'https://deno.land/x/og_edge/mod.ts'

export default async function handler(req: Request) {
  return new ImageResponse(
    (
      <div
        style={{
          width: '100%',
          height: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          fontSize: 128,
          background: 'lavender',
        }}
      >
        Hello world!
      </div>
    ),
  )
}
```

Now goto `localhost:4321/api/og-image` and check our the beautiful hello world! Nothing special happening here, yet.

## Getting dynamic

The magic of automated open graph images is that they can be generated at run time based on whatever URL search parameters are provided. User name, blog post title, address, product rating, price, etc. You can get as creative as you want here because it happens at run time, not build time.

This information is passed to our image generation API using [URL search params](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams). A really simple example is something like this: `https://www.my-site.com/api/og-image?title=Hello%20World`.

The important bits to notice are everything that comes after the `?` mark where we pass the title as a search parameter to the edge function. Our edge function can then decode these search params and to use in our image as variables.

Here is an example building on what we had before to include a dynamic title in the image:

```tsx title="og-image.ts" {6-7, 22}
/** @jsxImportSource https://esm.sh/react */
import React from 'https://esm.sh/react@18.2.0'
import { ImageResponse } from 'https://deno.land/x/og_edge/mod.ts'

export default async function handler(req: Request) {
  const { searchParams } = new URL(req.url)
  const title = searchParams.get('title')

  return new ImageResponse(
    (
      <div
        style={{
          width: '100%',
          height: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          fontSize: 128,
          background: 'lavender',
        }}
      >
        {title}
      </div>
    ),
  )
}
```

## Rendering engine

The HTML and CSS are rendered to an image using the [Satori rendering engine](https://github.com/vercel/satori). Satori gives you a limited subset of CSS and HTML to work with focusing on properties that affect visual appearance like color, borders, shadows, etc. The big win is that Satori lets you customize fonts, inserts SVGs, and even basic images.

The key here is that you need to work within the limitations of what is possible both with the rendering engine and also edge functions. At the time of writing CPU execution time is limited to 50ms for an edge function. Inlined SVGs give you a lot of creative freedom to keep the response times fast on the edge function while still adding visual pop.

<BlogQuoteInfo>
  Satori uses _only_ flexbox for layout, meaning you can't use CSS grid at this
  time for managing element position.
</BlogQuoteInfo>
